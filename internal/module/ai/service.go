package ai

import (
	"bloggo/internal/config"
	"bloggo/internal/module/ai/models"
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"
)

type AIService interface {
	GenerateContentMetadata(
		content string,
		availableCategories []string,
	) (*models.ResponseGenerativeFill, error)
}

type GeminiService struct {
	apiKey string
	client *http.Client
}

func NewAIService() AIService {
	if !config.IsGeminiEnabled() {
		return &DisabledAIService{}
	}

	return &GeminiService{
		apiKey: config.Get().GeminiAPIKey,
		client: &http.Client{
			Timeout: 30 * time.Second,
		},
	}
}

type DisabledAIService struct{}

func (service *DisabledAIService) GenerateContentMetadata(
	content string,
	availableCategories []string,
) (*models.ResponseGenerativeFill, error) {
	return nil, errors.New(
		"gemini ai service is not enabled - please configure an api key",
	)
}

type GeminiRequest struct {
	Contents []struct {
		Parts []struct {
			Text string `json:"text"`
		} `json:"parts"`
	} `json:"contents"`
	GenerationConfig struct {
		Temperature     float32 `json:"temperature"`
		TopK            int     `json:"topK"`
		TopP            float32 `json:"topP"`
		MaxOutputTokens int     `json:"maxOutputTokens"`
	} `json:"generationConfig"`
}

type GeminiResponse struct {
	Candidates []struct {
		Content struct {
			Parts []struct {
				Text string `json:"text"`
			} `json:"parts"`
		} `json:"content"`
	} `json:"candidates"`
}

func (service *GeminiService) GenerateContentMetadata(
	content string,
	availableCategories []string,
) (*models.ResponseGenerativeFill, error) {
	if len(content) < 1000 {
		return nil, errors.New("content must be at least 1000 characters long")
	}

	categoriesStr := "any appropriate category"
	if len(availableCategories) > 0 {
		categoriesStr = fmt.Sprintf("one of these existing categories: %s", strings.Join(availableCategories, ", "))
	}

	prompt := fmt.Sprintf(
		`Analyze the following blog post content and generate appropriate metadata. Return a valid JSON object with these exact fields:
- "title": An engaging, SEO-friendly title (max 100 characters)
- "metaDescription": A compelling meta description (70-155 characters)
- "spot": A brief excerpt or teaser (max 75 characters)
- "suggestedCategory": Select the best fit from this categories: [%s]

Content to analyze:
%s

Return only valid JSON, no additional text or formatting.`,
		categoriesStr,
		content,
	)

	reqBody := GeminiRequest{
		Contents: []struct {
			Parts []struct {
				Text string `json:"text"`
			} `json:"parts"`
		}{
			{
				Parts: []struct {
					Text string `json:"text"`
				}{
					{Text: prompt},
				},
			},
		},
		GenerationConfig: struct {
			Temperature     float32 `json:"temperature"`
			TopK            int     `json:"topK"`
			TopP            float32 `json:"topP"`
			MaxOutputTokens int     `json:"maxOutputTokens"`
		}{
			Temperature:     0.7,
			TopK:            40,
			TopP:            0.95,
			MaxOutputTokens: 1024,
		},
	}

	jsonData, err := json.Marshal(reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %v", err)
	}

	url := fmt.Sprintf(
		"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=%s",
		service.apiKey,
	)

	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %v", err)
	}

	req.Header.Set("Content-Type", "application/json")

	resp, err := service.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to call Gemini API: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf(
			"gemini api error (status %d): %s",
			resp.StatusCode, string(body),
		)
	}

	// Read the full response body for logging
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %v", err)
	}

	var geminiResp GeminiResponse
	if err := json.Unmarshal(body, &geminiResp); err != nil {
		return nil, fmt.Errorf("failed to decode Gemini response: %v", err)
	}

	if len(geminiResp.Candidates) == 0 ||
		len(geminiResp.Candidates[0].Content.Parts) == 0 {
		return nil, errors.New("no content generated by Gemini")
	}

	generatedText := geminiResp.Candidates[0].Content.Parts[0].Text
	generatedText = strings.TrimSpace(generatedText)

	// Remove markdown code block formatting if present
	if after, ok := strings.CutPrefix(generatedText, "```json"); ok {
		generatedText = after
		generatedText = strings.TrimSuffix(generatedText, "```")
		generatedText = strings.TrimSpace(generatedText)
	}

	var result models.ResponseGenerativeFill
	if err := json.Unmarshal([]byte(generatedText), &result); err != nil {
		return nil, fmt.Errorf(
			"failed to parse generated metadata JSON: %v. Generated text: %s",
			err,
			generatedText,
		)
	}

	return &result, nil
}
