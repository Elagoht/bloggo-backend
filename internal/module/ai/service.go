package ai

import (
	"bloggo/internal/config"
	"bloggo/internal/module/ai/models"
	"bloggo/internal/utils/apierrors"
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"
)

type AIService interface {
	GenerateContentMetadata(
		content string,
		availableCategories []string,
	) (*models.ResponseGenerativeFill, error)
	GenerateCategoryMetadata(
		categoryName string,
	) (*models.ResponseCategoryGenerativeFill, error)
}

type GeminiService struct {
	apiKey string
	client *http.Client
}

func NewAIService() AIService {
	if !config.IsGeminiEnabled() {
		return &DisabledAIService{}
	}

	return &GeminiService{
		apiKey: config.Get().GeminiAPIKey,
		client: &http.Client{
			Timeout: 30 * time.Second,
		},
	}
}

type DisabledAIService struct{}

func (service *DisabledAIService) GenerateContentMetadata(
	content string,
	availableCategories []string,
) (*models.ResponseGenerativeFill, error) {
	return nil, apierrors.ErrAIFeaturesDisabled
}

func (service *DisabledAIService) GenerateCategoryMetadata(
	categoryName string,
) (*models.ResponseCategoryGenerativeFill, error) {
	return nil, apierrors.ErrAIFeaturesDisabled
}

type GeminiRequest struct {
	Contents []struct {
		Parts []struct {
			Text string `json:"text"`
		} `json:"parts"`
	} `json:"contents"`
	GenerationConfig struct {
		Temperature     float32 `json:"temperature"`
		TopK            int     `json:"topK"`
		TopP            float32 `json:"topP"`
		MaxOutputTokens int     `json:"maxOutputTokens"`
	} `json:"generationConfig"`
}

type GeminiResponse struct {
	Candidates []struct {
		Content struct {
			Parts []struct {
				Text string `json:"text"`
			} `json:"parts"`
		} `json:"content"`
	} `json:"candidates"`
}

func (service *GeminiService) GenerateContentMetadata(
	content string,
	availableCategories []string,
) (*models.ResponseGenerativeFill, error) {
	if len(content) < 1000 {
		return nil, errors.New("content must be at least 1000 characters long")
	}

	categoriesStr := "any appropriate category"
	if len(availableCategories) > 0 {
		categoriesStr = fmt.Sprintf("one of these existing categories: %s", strings.Join(availableCategories, ", "))
	}

	prompt := fmt.Sprintf(
		`Analyze the following blog post content and generate appropriate metadata. Return a valid JSON object with these exact fields:
- "title": An engaging, SEO-friendly title (max 100 characters)
- "metaDescription": A compelling meta description (70-155 characters)
- "spot": A brief excerpt or teaser (max 75 characters)
- "suggestedCategory": Select the best fit from this categories: [%s]

Content to analyze:
%s

Return only valid JSON, no additional text or formatting.`,
		categoriesStr,
		content,
	)

	reqBody := GeminiRequest{
		Contents: []struct {
			Parts []struct {
				Text string `json:"text"`
			} `json:"parts"`
		}{
			{
				Parts: []struct {
					Text string `json:"text"`
				}{
					{Text: prompt},
				},
			},
		},
		GenerationConfig: struct {
			Temperature     float32 `json:"temperature"`
			TopK            int     `json:"topK"`
			TopP            float32 `json:"topP"`
			MaxOutputTokens int     `json:"maxOutputTokens"`
		}{
			Temperature:     0.7,
			TopK:            40,
			TopP:            0.95,
			MaxOutputTokens: 1024,
		},
	}

	jsonData, err := json.Marshal(reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %v", err)
	}

	url := fmt.Sprintf(
		"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=%s",
		service.apiKey,
	)

	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %v", err)
	}

	req.Header.Set("Content-Type", "application/json")

	resp, err := service.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to call Gemini API: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf(
			"gemini api error (status %d): %s",
			resp.StatusCode, string(body),
		)
	}

	// Read the full response body for logging
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %v", err)
	}

	var geminiResp GeminiResponse
	if err := json.Unmarshal(body, &geminiResp); err != nil {
		return nil, fmt.Errorf("failed to decode Gemini response: %v", err)
	}

	if len(geminiResp.Candidates) == 0 ||
		len(geminiResp.Candidates[0].Content.Parts) == 0 {
		return nil, errors.New("no content generated by Gemini")
	}

	generatedText := geminiResp.Candidates[0].Content.Parts[0].Text
	generatedText = strings.TrimSpace(generatedText)

	// Remove markdown code block formatting if present
	if after, ok := strings.CutPrefix(generatedText, "```json"); ok {
		generatedText = after
		generatedText = strings.TrimSuffix(generatedText, "```")
		generatedText = strings.TrimSpace(generatedText)
	}

	var result models.ResponseGenerativeFill
	if err := json.Unmarshal([]byte(generatedText), &result); err != nil {
		return nil, fmt.Errorf(
			"failed to parse generated metadata JSON: %v. Generated text: %s",
			err,
			generatedText,
		)
	}

	return &result, nil
}

func (service *GeminiService) GenerateCategoryMetadata(
	categoryName string,
) (*models.ResponseCategoryGenerativeFill, error) {
	if len(categoryName) == 0 {
		return nil, errors.New("category name cannot be empty")
	}

	prompt := fmt.Sprintf(
		`Generate appropriate metadata for a blog category named "%s". Return a valid JSON object with these exact fields:

- "spot": A brief, engaging description (MUST be max 75 characters)
- "description": A meta description for SEO (MUST be between 70-155 characters)

The content should be SEO-friendly and help readers understand what topics they'll find in this category. Keep descriptions concise and within the specified character limits. Do not use ellipsis. Generate complete sentences. Uncompleted sentences isn't allowed.

Return only valid JSON, no additional text or formatting.`,
		categoryName,
	)

	reqBody := GeminiRequest{
		Contents: []struct {
			Parts []struct {
				Text string `json:"text"`
			} `json:"parts"`
		}{
			{
				Parts: []struct {
					Text string `json:"text"`
				}{
					{Text: prompt},
				},
			},
		},
		GenerationConfig: struct {
			Temperature     float32 `json:"temperature"`
			TopK            int     `json:"topK"`
			TopP            float32 `json:"topP"`
			MaxOutputTokens int     `json:"maxOutputTokens"`
		}{
			Temperature:     0.7,
			TopK:            40,
			TopP:            0.95,
			MaxOutputTokens: 512,
		},
	}

	jsonData, err := json.Marshal(reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %v", err)
	}

	url := fmt.Sprintf(
		"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=%s",
		service.apiKey,
	)

	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %v", err)
	}

	req.Header.Set("Content-Type", "application/json")

	resp, err := service.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to call Gemini API: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf(
			"gemini api error (status %d): %s",
			resp.StatusCode, string(body),
		)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %v", err)
	}

	var geminiResp GeminiResponse
	if err := json.Unmarshal(body, &geminiResp); err != nil {
		return nil, fmt.Errorf("failed to decode Gemini response: %v", err)
	}

	if len(geminiResp.Candidates) == 0 ||
		len(geminiResp.Candidates[0].Content.Parts) == 0 {
		return nil, errors.New("no content generated by Gemini")
	}

	generatedText := geminiResp.Candidates[0].Content.Parts[0].Text
	generatedText = strings.TrimSpace(generatedText)

	// Remove markdown code block formatting if present
	if after, ok := strings.CutPrefix(generatedText, "```json"); ok {
		generatedText = after
		generatedText = strings.TrimSuffix(generatedText, "```")
		generatedText = strings.TrimSpace(generatedText)
	}

	var result models.ResponseCategoryGenerativeFill
	if err := json.Unmarshal([]byte(generatedText), &result); err != nil {
		return nil, fmt.Errorf(
			"failed to parse generated category metadata JSON: %v. Generated text: %s",
			err,
			generatedText,
		)
	}

	// Ensure character limits are enforced
	if len(result.Spot) > 75 {
		// Truncate at word boundary if possible
		truncated := result.Spot[:72]
		if lastSpace := strings.LastIndex(truncated, " "); lastSpace > 50 {
			truncated = result.Spot[:lastSpace]
		}
		result.Spot = truncated + "..."
	}

	if len(result.Description) > 155 {
		// Truncate at word boundary if possible
		truncated := result.Description[:152]
		if lastSpace := strings.LastIndex(truncated, " "); lastSpace > 130 {
			truncated = result.Description[:lastSpace]
		}
		result.Description = truncated + "..."
	}

	// Ensure minimum length for description
	if len(result.Description) < 70 {
		return nil, errors.New("generated description is too short (minimum 70 characters)")
	}

	return &result, nil
}
